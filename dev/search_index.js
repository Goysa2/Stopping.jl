var documenterSearchIndex = {"docs":
[{"location":"api/#State-1","page":"API","title":"State","text":"","category":"section"},{"location":"api/#Types-1","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Stopping.GenericStatemod\nStopping.NLPAtX\nStopping.LSAtT","category":"page"},{"location":"api/#Stopping.NLPAtX","page":"API","title":"Stopping.NLPAtX","text":"Type: NLPAtX Methods: update!, reinit!\n\nNLPAtX contains the information concerning a nonlinear problem at the iteration x. min_{x ∈ ℜⁿ} f(x) subject to lcon <= c(x) <= ucon, lvar <= x <= uvar.\n\nBasic information is:\n\nx : the current candidate for solution to our original problem\nfx : which is the funciton evaluation at x\ngx : which is the gradient evaluation at x\nHx : which is the hessian representation at x\nmu : Lagrange multiplier of the bounds constraints\ncx : evaluation of the constraint function at x\nJx : jacobian matrix of the constraint function at x\nlambda : Lagrange multiplier of the constraints\ncurrent_time  : time\ncurrent_score : score\nevals : number of evaluations of the function (import the type NLPModels.Counters)\n\nNote: * by default, unknown entries are set to nothing (except evals).       * All these information (except for x and lambda) are optionnal and need to be update when         required. The update is done trhough the update! function.       * x and lambda are mandatory entries. If no constraints lambda = [].       * The constructor check the size of the entries.\n\n\n\n\n\n","category":"type"},{"location":"api/#Stopping.LSAtT","page":"API","title":"Stopping.LSAtT","text":"Type: LSAtT Methods: update!, reinit!, copy\n\nA structure designed to track line search information from one iteration to another. If we have f : ℜⁿ → ℜ, then we define h(θ) = f(x + θ*d) where x and d are vectors of same dimension and θ is a scalar, more specifically our step size.\n\nTracked data can include:\n\nx : our current step size\nht : h(θ) at the current iteration\ngt : h'(θ)\nh₀ : h(0)\ng₀ : h'(0)\ncurrent_time:  the time at which the line search algorithm started.\ncurrent_score: the score at which the line search algorithm started.\n\nNote: by default, unknown entries are set to nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#General-Functions-1","page":"API","title":"General Functions","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Stopping.update!\nStopping.reinit!","category":"page"},{"location":"api/#Stopping.update!","page":"API","title":"Stopping.update!","text":"update!: generic update function for the State\n\nThe function compare the kwargs and the entries of the State. If the type of the kwargs is the same as the entry or the entry was nothing, then it is updated.\n\nSet convert to true, to update even incompatible types.\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping.reinit!","page":"API","title":"Stopping.reinit!","text":"reinit!: function that set all the entries at void except the mandatory x\n\nNote: If x is given as a keyword argument it will be prioritized over the argument x.\n\n\n\n\n\nreinit!: shorter version of reinit! reusing the x in the state\n\nNote: If x is given as a keyword argument it will be prioritized over the argument x.\n\n\n\n\n\nreinit!: function that set all the entries at void except the mandatory x\n\nWarning: if x, lambda or evals are given as a keyword argument they will be prioritized over the existing x, lambda and the default Counters.\n\n\n\n\n\nreinit!: short version of reinit! reusing the x in the state\n\nWarning: if x, lambda or evals are given as a keyword argument they will be prioritized over the existing x, lambda and the default Counters.\n\n\n\n\n\nreinit!: Reinitialize the meta data.\n\nIf rstate is set as true it reinitialize the current_state  (with the kwargs)\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping-1","page":"API","title":"Stopping","text":"","category":"section"},{"location":"api/#Types-2","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Stopping.GenericStopping\nStopping.NLPStopping\nStopping.LS_Stopping\nStopping.StoppingMeta","category":"page"},{"location":"api/#Stopping.GenericStopping","page":"API","title":"Stopping.GenericStopping","text":"Type: GenericStopping  Methods: start!, stop!, updateandstart!, updateandstop!, fill_in!, reinit!, status\n\nA generic stopping criterion to solve instances (pb) with respect to some  optimality conditions. Optimality is decided by computing a score, which is then  tested to zero.\n\nBesides optimality conditions, we consider classical emergency exit:\n\ndomain error        (for instance: NaN in x)\nunbounded problem   (not implemented)\nunbounded x         (x is too large)\ntired problem       (time limit attained)\nresources exhausted (not implemented)\nstalled problem     (not implemented)\niteration limit     (maximum number of iteration (i.e. nb of stop) attained)\nmain_pb limit       (tired or resources of main problem exhausted)\n\nInput :     - pb         : A problem     - state      : The information relative to the problem, see GenericState     - (opt) meta : Metadata relative to stopping criterion.     - (opt) main_stp : Stopping of the main loop in case we consider a Stopping                        of a subproblem.                        If not a subproblem, then nothing.\n\nNote: Metadata can be provided by the user or created with the Stopping        constructor with kwargs. If a specific StoppingMeta is given and        kwargs are provided, the kwargs have priority.\n\n\n\n\n\n","category":"type"},{"location":"api/#Stopping.NLPStopping","page":"API","title":"Stopping.NLPStopping","text":"Type: NLPStopping (specialization of GenericStopping) Methods: start!, stop!, updateandstart!, updateandstop!, fill_in!, reinit!, status\n\nStopping structure for non-linear programming problems using NLPModels.     Input :        - pb         : an AbstractNLPModel        - optimalitycheck : a stopping criterion through an admissibility function        - state      : The information relative to the problem, see GenericState        - maxcntrs  : Dict contains the max number of evaluations        - (opt) meta : Metadata relative to stopping criterion.        - (opt) main_stp : Stopping of the main loop in case we consider a Stopping                           of a subproblem.                           If not a subproblem, then nothing.\n\nNote:\n\noptimality_check : takes two inputs (AbstractNLPModel, NLPAtX)\n\nand returns a Float64 to be compared at 0.\n\ndesigned for NLPAtX State. Constructor checks that the State has the\n\nrequired entries.\n\nWarning:\n\noptimality_check does not necessarily fill in the State.\n\n\n\n\n\n\n\n","category":"type"},{"location":"api/#Stopping.LS_Stopping","page":"API","title":"Stopping.LS_Stopping","text":"Type: LSStopping (specialization of GenericStopping) Methods: start!, stop!, updateandstart!, updateandstop!, fillin!, reinit!, status\n\nLS_Stopping is designed to handle the stopping criterion of line search problems. Let f:R→Rⁿ, then h(t) = f(x+td) where x and d are vectors and t is a scalar. h is such that h:R→R.\n\nStopping structure for non-linear programming problems using NLPModels.     Input :        - pb         : an AbstractNLPModel        - optimalitycheck : a stopping criterion through an admissibility function        - state      : The information relative to the problem, see GenericState        - (opt) meta : Metadata relative to stopping criterion.        - (opt) mainstp : Stopping of the main loop in case we consider a Stopping                           of a subproblem.                           If not a subproblem, then nothing.\n\nNote:\n\nThe pb can be a LineModel defined in SolverTools.jl (https://github.com/JuliaSmoothOptimizers/SolverTools.jl)\nIt is possible to define those stopping criterion in a NLPStopping except NLPStopping uses vectors operations. LS_Stopping and it's admissible functions (Armijo and Wolfe are provided with Stopping.jl) uses scalar operations.\noptimalitycheck(pb, state; kwargs...) -> Float64 For instance, the armijo condition is: h(t)-h(0)-τ₀th'(0) ⩽ 0 therefore armijo(h, hat_t) returns the maximum between h(t)-h(0)-τ₀th'(0) and 0.\n\n\n\n\n\n\n\n","category":"type"},{"location":"api/#Stopping.StoppingMeta","page":"API","title":"Stopping.StoppingMeta","text":"Type: StoppingMeta Methods: no\n\nCommon stopping criteria for algorithms:     - absolute and relative tolerance     - threshold for unboundedness     - time limit to let the algorithm run     - maximum number of function (and derivatives) evaluations\n\nIt's a mutable struct therefore we can modified elements of a StoppingMeta. \t- The nbofstop is incremented everytime stop! or updateandstop! is called \t- The optimality0 is modified once at the beginning of the algorithm (start!)     - The starttime is modified once at the beginning of the algorithm (start!)       if not precised before. \t- The different status: failsubpb, unbounded, unboundedpb, tired, stalled,       iterationlimit, resources, optimal, mainpb, domainerror, suboptimal, infeasible\n\nNote: failsubpb, suboptimal, and infeasible are modified by the algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/#General-Functions-2","page":"API","title":"General Functions","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Stopping.start!\nStopping.update_and_start!\nStopping.stop!\nStopping.update_and_stop!\nStopping.reinit!\nStopping.fill_in!\nStopping.status","category":"page"},{"location":"api/#Stopping.start!","page":"API","title":"Stopping.start!","text":"start!: update the Stopping and return a boolean true if we must stop.\n\nPurpose is to know if there is a need to even perform an optimization algorithm  or if we are at an optimal solution from the beginning.\n\nNote: * start! initialize the starttime (if not done before) and meta.optimality0.        * Keywords argument are sent to the _optimalitycheck!\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping.update_and_start!","page":"API","title":"Stopping.update_and_start!","text":"updateandstart!: Update the values in the State and initializes the Stopping Returns the optimity status of the problem.\n\nKwargs are forwarded to the update!(stp.current_state)\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping.stop!","page":"API","title":"Stopping.stop!","text":"stop!: update the Stopping and return a boolean true if we must stop.\n\nserves the same purpose as start! in an algorithm, tells us if we stop the algorithm (because we have reached optimality or we loop infinitely, etc).\n\nKeywords argument are sent to the optimalitycheck!\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping.update_and_stop!","page":"API","title":"Stopping.update_and_stop!","text":"updateandstop!: update the values in the State and returns the optimality status of the problem.\n\nkwargs are forwarded to the update!(stp.current_state)\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping.fill_in!","page":"API","title":"Stopping.fill_in!","text":"fill_in!: A function that fill in the unspecified values of the AbstractState.\n\nNotImplemented for Abstract/Generic-Stopping.\n\n\n\n\n\nfill_in!: a function that fill in the required values in the State\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping.status","page":"API","title":"Stopping.status","text":"status: returns the status of the algorithm:     - Optimal : if we reached an optimal solution     - Unbounded : if the problem doesn't have a lower bound     - Stalled : if algorithm is stalling     - IterationLimit : if we did too  many iterations of the algorithm     - Tired : if the algorithm takes too long     - ResourcesExhausted: if we used too many ressources,                           i.e. too many functions evaluations     - ResourcesOfMainProblemExhausted: in the case of a substopping, ResourcesExhausted or Tired     for the main stopping.     - Infeasible : default return value, if nothing is done the problem is                    considered infeasible     - DomainError : there is a NaN somewhere\n\nNote: set keyword argument list to true, to get an Array with all the status.\n\n\n\n\n\n","category":"function"},{"location":"api/#Non-linear-admissibility-functions-1","page":"API","title":"Non linear admissibility functions","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Stopping.KKT\nStopping.unconstrained_check\nStopping.unconstrained2nd_check\nStopping.optim_check_bounded","category":"page"},{"location":"api/#Stopping.KKT","page":"API","title":"Stopping.KKT","text":"KKT: verifies the KKT conditions\n\nrequired: state.gx\n\nif bounds: state.mu\nif constraints: state.cx, state.Jx, state.lambda\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping.unconstrained_check","page":"API","title":"Stopping.unconstrained_check","text":"unconstrained: return the infinite norm of the gradient of the objective function\n\nrequired: state.gx (filled if nothing)\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping.unconstrained2nd_check","page":"API","title":"Stopping.unconstrained2nd_check","text":"unconstrained 2nd: check the norm of the gradient and the smallest                    eigenvalue of the hessian.\n\nrequired: state.gx, state.Hx (filled if nothing)\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping.optim_check_bounded","page":"API","title":"Stopping.optim_check_bounded","text":"optimcheckbounded: gradient of the objective function projected\n\nrequired: state.gx (filled if void)\n\n\n\n\n\n","category":"function"},{"location":"api/#Line-search-admissibility-functions-1","page":"API","title":"Line search admissibility functions","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Stopping.armijo\nStopping.wolfe\nStopping.armijo_wolfe\nStopping.shamanskii_stop\nStopping.goldstein","category":"page"},{"location":"api/#Stopping.armijo","page":"API","title":"Stopping.armijo","text":"armijo: check if a step size is admissible according to the Armijo criterion.\n\nArmijo criterion: f(x + θd) - f(x) < τ₀ θ ∇f(x+θd)d\n\nNote: ht, h₀ and g₀ are required in the LSAtT\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping.wolfe","page":"API","title":"Stopping.wolfe","text":"wolfe: check if a step size is admissible according to the Wolfe criterion.\n\nStrong Wolfe criterion: |∇f(x+θd)| < τ₁||∇f(x)||.\n\nNote: gt and g₀ are required in the LSAtT\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping.armijo_wolfe","page":"API","title":"Stopping.armijo_wolfe","text":"armijo_wolfe: check if a step size is admissible according to the Armijo and Wolfe criteria.\n\nNote: ht, h₀, gt and g₀ are required in the LSAtT\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping.shamanskii_stop","page":"API","title":"Stopping.shamanskii_stop","text":"shamanskii_stop: check if a step size is admissible according to the \"Shamanskii\" criteria. This criteria was proposed in \tGLOBAL CONVERGENCE TECHNIQUE FOR THE NEWTON METHOD WITH PERIODIC HESSIAN EVALUATION \tby \tF. LAMPARIELLO and M. SCIANDRONE\n\nNote: * h.d accessible (specific LineModel)       * ht, h₀ are required in the LSAtT\n\n\n\n\n\n","category":"function"},{"location":"api/#Stopping.goldstein","page":"API","title":"Stopping.goldstein","text":"goldstein: check if a step size is admissible according to the Goldstein criteria.\n\nNote: ht, h₀ and g₀ are required in the LSAtT\n\n\n\n\n\n","category":"function"},{"location":"#Stopping.jl-1","page":"Home","title":"Stopping.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Documentation for Stopping.jl","category":"page"},{"location":"#Purpose-1","page":"Home","title":"Purpose","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Tools to ease the uniformization of stopping criteria in iterative solvers.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"When a solver is called on an optimization model, four outcomes may happen:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"the approximate solution is obtained, the problem is considered solved\nthe problem is declared unsolvable (unboundedness, infeasibility ...)\nthe maximum available resources are not sufficient to compute the solution\nsome algorithm dependent failure happens","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This tool eases the first three items above. It defines a type","category":"page"},{"location":"#","page":"Home","title":"Home","text":"mutable struct GenericStopping <: AbstractStopping\n    problem       :: Any          # an arbitrary instance of a problem\n    meta          :: AbstractStoppingMeta # contains the used parameters\n    current_state :: AbstractState        # the current state","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The StoppingMeta provides default tolerances, maximum resources, ...  as well as (boolean) information on the result.","category":"page"},{"location":"#Your-Stopping-your-way-1","page":"Home","title":"Your Stopping your way","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The GenericStopping (with GenericState) provides a complete structure to handle stopping criteria. Then, depending on the problem structure, you can specialize a new Stopping by redefining a State and some functions specific to your problem.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We provide some specialization of the GenericStopping for optimization:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"NLPStopping with NLPAtX as a specialized State: for non-linear programming (based on NLPModels);\nLS_Stopping with LSAtT as a specialized State: for 1d optimization;\nmore to come...","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In these examples, the function optimality_residual computes the residual of the optimality conditions is an additional attribute of the types.","category":"page"},{"location":"#Functions-1","page":"Home","title":"Functions","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The tool provides two main functions:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"start!(stp :: AbstractStopping) initializes the time and the tolerance at the starting point and check wether the initial guess is optimal.\nstop!(stp :: AbstractStopping) checks optimality of the current guess as well as failure of the system (unboundedness for instance) and maximum resources (number of evaluations of functions, elapsed time ...)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Stopping uses the informations furnished by the State to evaluate its functions. Communication between the two can be done through the following functions:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"update_and_start!(stp :: AbstractStopping; kwargs...) updates the states with informations furnished as kwargs and then call start!.\nupdate_and_stop!(stp :: AbstractStopping; kwargs...) updates the states with informations furnished as kwargs and then call stop!.\nfill_in!(stp :: AbstractStopping, x :: Iterate) a function that fill in all the State with all the informations required to correctly evaluate the stopping functions. This can reveal useful, for instance, if the user do not trust the informations furnished by the algorithm in the State.\nreinit!(stp :: AbstractStopping) reinitialize the entries of","category":"page"},{"location":"#","page":"Home","title":"Home","text":"the Stopping to reuse for another call.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Consult the HowTo tutorial to learn more about the possibilities offered by Stopping.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can also access other examples of algorithms in the test/examples folder, which for instance illustrate the strenght of Stopping with subproblems:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Consult the OptimSolver tutorial for more on how to use Stopping with nested algorithms.\nCheck the Benchmark tutorial to see how Stopping can combined with SolverBenchmark.jl.\nStopping can be adapted to closed solvers via a buffer function as in Buffer tutorial for an instance with Ipopt via NLPModelsIpopt.","category":"page"},{"location":"#How-to-install-1","page":"Home","title":"How to install","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Install and test the Stopping package with the Julia package manager:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add Stopping\npkg> test Stopping","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can access the most up-to-date version of the Stopping package using:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add https://github.com/Goysa2/Stopping.jl\npkg> test Stopping","category":"page"},{"location":"#Example-1","page":"Home","title":"Example","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"As an example, a naive version of the Newton method is provided here. First we import the packages:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using LinearAlgebra, NLPModels, Stopping","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We consider a quadratic test function, and create an uncontrained quadratic optimization problem using NLPModels:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A = rand(5, 5); Q = A' * A;\nf(x) = 0.5 * x' * Q * x\nnlp = ADNLPModel(f,  ones(5))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We now initialize the NLPStopping. First create a State.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"nlp_at_x = NLPAtX(ones(5))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We use unconstrained_check as an optimality function","category":"page"},{"location":"#","page":"Home","title":"Home","text":"stop_nlp = NLPStopping(nlp, unconstrained_check, nlp_at_x)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that, since we used a default State, an alternative would have been:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"stop_nlp = NLPStopping(nlp)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Now a basic version of Newton to illustrate how to use Stopping.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"function newton(stp :: NLPStopping)\n\n    #Notations\n    pb = stp.pb; state = stp.current_state;\n    #Initialization\n    xt = state.x\n\n    #First, call start! to check optimality and set an initial configuration\n    #(start the time counter, set relative error ...)\n    OK = update_and_start!(stp, x = xt, gx = grad(pb, xt), Hx = hess(pb, xt))\n\n    while !OK\n        #Compute the Newton direction (state.Hx only has the lower triangular)\n        d = (state.Hx + state.Hx' - diagm(0 => diag(state.Hx))) \\ (- state.gx)\n        #Update the iterate\n        xt = xt + d\n        #Update the State and call the Stopping with stop!\n        OK = update_and_stop!(stp, x = xt, gx = grad(pb, xt), Hx = hess(pb, xt))\n    end\n\n    return stp\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally, we can call the algorithm with our Stopping:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"stop_nlp = newton(stop_nlp)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and consult the Stopping to know what happened","category":"page"},{"location":"#","page":"Home","title":"Home","text":"#We can then ask stop_nlp the final status\n@test :Optimal in status(stop_nlp, list = true)\n#Explore the final values in stop_nlp.current_state\nprintstyled(\"Final solution is $(stop_nlp.current_state.x)\", color = :green)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We reached optimality, and thanks to the Stopping structure this simple looking algorithm verified at each step of the algorithm:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"time limit has been respected;\nevaluations of the problem are not excessive;\nthe problem is not unbounded (w.r.t. x and f(x));\nthere is no NaN in x, f(x), g(x), H(x);\nthe maximum number of iteration (call to stop!) is limited.","category":"page"},{"location":"#Long-Term-Goals-1","page":"Home","title":"Long-Term Goals","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Stopping is aimed as a tool for improving the reusability and robustness in the implementation of iterative algorithms. We warmly welcome any feedback or comment leading to potential improvements.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Future work will address more sophisticated problems such as mixed-integer optimization problems, optimization with uncertainty. The list of suggested optimality functions will be enriched with state of the art conditions.","category":"page"},{"location":"tutorial/#Tutorials-and-examples-1","page":"Examples and tutorials","title":"Tutorials and examples","text":"","category":"section"},{"location":"tutorial/#","page":"Examples and tutorials","title":"Examples and tutorials","text":"Many tutorials and example are available here, among them :     - a basic Julia implementation of a Newton method using Stopping,     - a Julia implementation of a penalty algorithm,     - how to use Stopping to simplify benchmarking of algorithm and       - how to converting existing algorithms to Stopping.","category":"page"},{"location":"tutorial/#","page":"Examples and tutorials","title":"Examples and tutorials","text":"If you encounter any problems with Stopping, please post an issue on Github. Issues and pull requests will help improve Stopping as well as the documentation.  ","category":"page"}]
}
